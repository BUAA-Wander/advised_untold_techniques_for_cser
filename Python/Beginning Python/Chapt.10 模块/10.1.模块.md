# 10.1.模块

- 程序: 又称脚本
- 使用`import`语句导入模块或模块中的对象

```python3
import module  # 导入模块
from package import module  # 从包中导入模块

from module import object  # 从模块中导入对象
from module import *  # 导入模块中的所有 (公有) 对象
```

## 1. 模块就是程序

- 模块就是程序: 任何Python程序都可作为模块导入
- 导入模块时, 将在模块作用域下执行其中代码, 并可能将其中定义的某些属性合并到另一个模块 (全局) 作用域中
- Python程序的文件主名 (不包括扩展名`.py`) 就是模块的名称
- Python可能会在模块所在目录下创建`__pycache__`子目录或`.pyc`文件 (旧版本下), 这是处理后的模块文件
    - 比起源代码文件, Python能更高效地运行处理后的模块文件
    - 未来导入或运行模块时, 如果源代码文件未发生变化, 将导入或运行处理后的文件, 否则将重新生成处理后的文件
    - 可以删除`__pycache__`或`.pyc`, 必要时Python将重新创建它们
- 模块用于定义属性 (变量, 函数, 类等), 而非执行操作
- 模块只会被导入一次, 重复导入会被忽略
- 只导入一次能够解决循环导入的问题: 当两个模块彼此导入对方时, 若不忽略重复的导入, 将形成无限的导入循环
- `importlib.reload(module) -> reloaded_module`: 重新加载并返回新版本模块
    - 可用于将在程序运行时对模块的修改反映到程序中: `module = importlib.reload(module)`
    - 注意: 旧版本模块及其作用域并不会消失
        - 通过实例化旧版本模块中的类所创建的对象, 在重新加载模块后, 并不会自动成为新版本模块中新版本类的对象, 而依然是来自旧版本模块的旧版本类的对象. 要让旧版本模块中旧版本类的实例成为新版本模块中新版本类的实例, 需要用新版本模块中的新版本类重新创建该实例

## 2. 模块是用来下定义的

- 模块与类类似, 有自己的作用域, 其中定义的名称 (类, 函数, 变量) 都是模块的属性

### 2.1. 在模块中定义函数

- 使用Python解释器开关`-m`来将模块作为程序执行而非导入: `python -m module arguments`
    - 相当于`python module.py`
    - `arguments`: 提供给模块的命令行参数
- 通过`module.attribute`访问模块作用域下的名称
- 通过模块化代码使其可重用: 通过将代码放在模块中, 就可在多个程序中使用这些代码

### 2.2. 在模块中添加测试代码

- 可以在模块中添加测试代码来检查模块
- 模块中的变量`__name__`
    - 当模块作为程序运行时 (包括在交互式解释器中), 其值为字符串`'__main__'`
    - 当模块被导入时, 其值为模块名字符串`'module'`
- 可通过检查`__name__`的值来判断当前模块是作为程序运行还是被导入
- 使用如下结构来使测试程序:
    - 在模块作为程序运行时执行
    - 在模块被导入时仅定义不执行
- 通过将测试代码放在函数`test()`中而非`if`语句中, 使模块可以在被导入后进行测试: `module.test()`

```python3
def test():
    # ...

if __name__ == '__main__':
    test()
```

- 对于更详尽的测试代码, 可以放在单独的模块中

## 3. 让模块可用

- `sys.path`是一个目录字符串列表
- Python以`sys.path`中的各路径为基路径搜索模块
- `PYTHONPATH`环境变量: 目录列表
    - 决定`sys.path`的初始值
    - 环境变量不是Python解释器的一部分, 而是操作系统的一部分
- 让模块可用 (可被Python找到) 的方法
    - 将模块放在正确的位置
    - 告诉解释器模块的搜索基目录
- Python打包技术: 让其他人能够轻松使用自己编写的模块: 参阅[Python打包用户指南](https://packaging.python.org)

### 3.1. 将模块放在正确的位置

- 将模块放在正确的位置: 将模块放在`sys.path`中任意搜索基目录下的对应位置
- `pprint.pprint(object)`: 妥善地打印内容
- `site-packages`搜索基目录: 用于放置用户模块
- 所有程序都能够导入位于默认搜索基目录下的模块
- `sys.path`默认包含主程序文件所在的目录

### 3.2. 告诉解释器到哪里去查找

- 不能将模块放到默认搜索基目录下的原因
    - 不希望Python解释器目录充斥着用户模块
    - 没有将模块保存到默认搜索基目录下的权限
    - 希望将模块保存在其他地方
- 如果将模块放到默认基目陆以外的其他地方, 就需要告诉解释器到哪里去查找模块
- 不推荐: 通过`sys.path.append(r'basedir')`向`sys.path`中添加搜索基路径
- 注意: 不能将包含`~`的路径添加到`sys.path`中, 而必须使用完整路径`/home/username`
    - `sys.path.expanduser(r'dir')`: 返回将`~`扩展后的完整路径
- 标准做法: 将模块所在的搜索基目录添加到环境变量`PYTHONPATH`中
    - 对于`bash`Shell
        - 通过`export PYTHONPATH=$PYTHONPATH:additional_path`命令将搜索基目录添加到`PYTHONPATH`末尾
        - 必须用引号将路径内的空格括起, 以避免Shell将路径分割开
        - 通过将该命令添加到`~/.bashrc`中来对所有的Shell默认执行该命令
- 可使用扩展名为`.pth`的路径配置文件来将搜索基目录添加到`sys.path`中
    - 位于特殊目录中
    - 包含要添加到`sys.path`中的搜索基目录

## 4. 包

- 包 Package: 可以包含其他模块的模块
- 普通模块是扩展名为`.py`的文件, 而包是包含`__init__.py`文件的目录
    - 文件`__init__.py`就是包作为模块的内容
    - 目录名就是包名
- 可将模块组织为包
    - 通过将模块文件放到包目录中来将模块包含到包中
    - 包可以包含其他包
- 模块名
    - 全限定名: `(package.)*module`
    - 简化名: `module`
- 通过`import (package.)*package`或`from package(.package)* import package`像普通模块一样导入包: 文件`__init__.py`的内容就是包的内容
    - 仅导入包作为模块的内容, 即包中`__init__.py`文件中的内容, 不导入包中的其他模块
- 注意: 可以只导入包中模块而不导入包本身
- 通过`import (package.)*module`导入模块, 导入后通过全限定名`(package.)*module`访问模块
- 通过`from package(.package)* import module`导入模块, 导入后通过简化名`module`访问模块
- 通过`from (package.)*module import attribute`导入模块属性, 导入后通过`attribute`访问属性
- 通过`from (package.)*module import *`导入模块中所有公有属性, 导入后通过`attribute`访问属性
- 可通过在`import`语句中添加`as alia`子句来重命名导入的模块或属性, 导入后通过`alia`访问模块或属性
