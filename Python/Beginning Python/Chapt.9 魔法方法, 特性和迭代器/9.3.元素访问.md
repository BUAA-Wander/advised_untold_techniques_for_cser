# 9.3.元素访问

- 协议: 规范行为的规则
    - 指定对象应该实现的方法及这些方法的行为
    - 类似于接口
- Python使用鸭子类型
    - Python: 对象的行为决定对象的类型
        - 多态基于对象的行为
        - 要求对象遵循特定协议以被视为某种对象
        - 例如: 要求对象遵循序列协议以被视为序列
    - 其他语言: 对象的类型决定对象的行为
        - 多态基于对象的 (祖先) 类型
        - 要求对象继承特定类型或接口以被视为某种对象
        - 例如: 要求对象继承序列接口以被视为序列
- 通过遵循序列或映射协议, 实现对应魔法方法, 来创建序列或映射对象

## 1. 基本的序列和映射协议

- 序列和映射是元素 item 的集合, 序列与映射协议是关于对象处理其中元素的协议
    - 对于序列来说, 元素是单个值
    - 对于映射来说, 元素是由键值对组成的项
- 为实现序列或映射的基本协议, 不可变对象需要实现两个方法, 可变对象需要实现四个方法
- `__len__(self) -> int`: 返回集合中元素的个数
    - 如果集合中元素个数为零, `__len__`返回零, 且没有实现覆盖布尔语义的`__nonzero__`, 对象在布尔型下被视为假
- `__getitem__(self, key) -> object`: 返回与指定键相关联的值
    - 对序列来说, 键是`[-__len(self)__, __len__(self)-1]`内的整数
        - 当键是负整数时, 应从末尾往前数, 即`sequence[-n]`等价于`sequence[len(sequence)-n]`
        - 如果键类型错误, 应引发`TypeError`异常
        - 如果键类型正确, 但不在允许范围内, 应引发`IndexError`异常
    - 对映射来说, 键可以是任何类型的对象
        - 若未找到指定元素, 应返回`None`
- `__setitem__(self, key, value) -> None`: 以与键相关联的方式存储值
    - 仅当对象可变且允许设置元素时才需要实现这个方法
- `__delitem__(self, key) -> None`: 删除与键相关联的值
    - 仅当对象可变且允许删除元素时才需要实现这个方法
    - 在对对象元素使用`del`语句时被调用
- 模块collections提供了抽象基类 (`Sequence`), 其文档描述了更复杂的协议

## 2. 从list, dict, str派生

- 序列协议有很多魔法和普通方法, 重新实现所有协议方法工作量大, 难度大
- 如果只希望定义某些操作的行为, 不应重新实现所有方法, 可以继承已有类型, 包括模块collections提供的抽象和具体基类, 以及内置类型
- 对于没有重写的方法, 可以直接调用; 对于重写的方法, 在重写时通过`super().method(argument_list)`调用超类相应方法, 并添加自定义行为
- 通过继承`list`类型来实现类似于内置列表的序列类型
- 通过继承`dict`类型来实现类似于内置字典的映射类型
- 注意: 重写`__getitem__`并不能保证捕获用户对元素的所有访问, 还有其他访问元素的方法, 如`pop`
