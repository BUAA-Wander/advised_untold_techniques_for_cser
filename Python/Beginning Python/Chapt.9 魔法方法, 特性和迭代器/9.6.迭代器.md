# 9.6.迭代器

## 1. 迭代器协议

- 迭代 Iterate: 重复多次
- 可迭代对象: 实现了`__iter__`方法的对象
- `__iter__(self) -> iterator`: 返回一个当前对象的迭代器
- `iter(object) -> iterator`: 内置函数, 返回可迭代对象或序列对象的一个迭代器
- `iter(callable, end_value) -> iterator`: 内置函数, 返回一个关于`callable`的迭代器, 该迭代器在每次被调用`__next__`方法时调用一次`callable`, 若`callable`返回值等于`end_value`, 则引发`StopIteration`异常; 否则, 返回`callable`返回值
- 迭代器对象: 实现了`__next__`方法的对象
- `__next__(self) -> next_element`: 如果仍有可返回的值, 返回下一个值; 如果没有可返回的值, 引发`StopIteration`异常
- 简单实现: 在同一个类中同时实现`__next__`与`__iter__`方法, 并在`__iter__`方法中返回`self`. 这样, 该类实例既是可迭代对象, 又是自己的迭代器
    - 注意: 对这样的对象迭代时, 将改变对象本身 (作为自身迭代器) 的状态
- `next(iterator) -> next_element`: 内置函数, 等价于`iterator.__next__()`
- 通常实现: 在一个类中实现`__iter__`方法, 使其成为可迭代类型; 在另一个类中实现`__next__`方法, 使其成为可迭代类型的迭代器类型, 并在可迭代类型的`__iter__`中创建并返回迭代器类型实例
    - 推荐在迭代器类型中也实现`__iter__`方法, 并在该方法中返回自身`self`, 使迭代器类型也成为可迭代类型, 其迭代器就是自身
- 迭代器比列表更通用, 简单, 优雅
- 迭代器可以处理无穷序列, 而列表不行
- 迭代器处理长序列占用很小内存, 而列表处理长序列占用大量内存
- `for`循环支持且仅支持对可迭代对象进行迭代: `for element in iterable:`
    - 试图通过`for`循环迭代非可迭代对象时将引发`TypeError`异常

## 2. 从迭代器创建序列

- 可以使用序列的情况大多也可使用迭代器和可迭代对象
- 构造函数`list`可将可迭代对象转换为列表: `list(iterable) -> list`
