# 7.1.对象魔法

- 对象: 一组数据与一组访问和操作这些数据的方法的集合
- 面向对象编程具有封装, 集成和多态的好处
- 抽象: 忽视不必要的细节
    - 封装和多态都是抽象的原则
- 封装 Encapsulation: 无需知道对象的**构造**就能使用它, 忽视构造细节
- 多态 Polymorphism: 无需知道对象的**类型**就能使用它, 忽视类型细节
    - 可对不同类型的对象执行相同的操作, 而这些操作可以适应每个对象各自的结构, 能够正常运行
    - 不确定变量所指的对象的类型, 也能对其执行操作, 且操作的行为将根据对象的类型而异, 自动适应对象的结构
    - 收到对象时, 只需知道它实现了指定的方法, 不需知道它如何实现的该方法 (它可能是众多类型, 形态中的任何一种), 即可正常使用和操作对象
- 继承: 基于通用类创建专用类

## 1. 多态

- 多态 Polymorphism: 无需知道对象的**类型**就能使用它
- `isinstance(object, class) -> bool`: 类型检查: 通常应避免使用
- 处理多种类型的类似对象
    - 根据对象所属的不同类型, 分别进行针对特定类型的操作, 既不灵活也不切实际, 扩展性差 (每出现一种新对象都要修改代码)
    - 封装+多态: 让对象自己实现这些操作对应的方法, 只调用对象所实现的方法来执行操作, 灵活, 扩展性强 (出现新对象时, 只要新对象实现了调用方式相同的方法, 就无需修改代码)

## 2. 多态和方法

- 通过点`.`操作符调用方法: `object.method(argument_list)`
- `random.choice(iterable) -> object`: 从可迭代对象中随机选择并返回一个元素
- 多态形式多样: 每当无需知道对象**类型**就能对其执行操作时, 都是多态在起作用
    - 方法: `object.method(argument_list)`
    - 运算符: `object operator object`
    - 函数: `fuction(object, argument_list)`
        - 内置函数`repr()`是多态的集大成者, 可以用于任何对象
- 多态将在代码中向上传递: 使用多态特性 (方法, 运算符, 函数) 所编写的代码本身也将是多态的
- 唯一破坏多态的方式是使用`type`, `isinstance`, `issubclass`等函数执行显式类型检查
    - 引入抽象基类与模块`abc`后, 函数`issubclass`本身也是多态的
- 避免破坏多态: 重要的是对象按自己希望的行事, 而非对象是否是正确的类型
- Python使用鸭子类型模型: 如果走起来像鸭子, 叫起来像鸭子, 那么它就是鸭子. 即: 结构决定类型, 而非类型决定结构

## 3. 封装

- 封装 Encapsulation: 无需知道对象的**构造**就能使用它
- 通过圆括号调用类来创建该类型的对象: `class(argument_list)`
- 属性: 与对象相关联, 归属于对象的变量
    - 通过将名称定义为属性而将它封装在对象中
    - 属性可用于在多次方法调用之间存储值
- 方法: 与对象相关联, 可以访问对象属性的函数
    - 可以理解为作为属性的函数
- 属性和方法统称特性 Feature
- 状态: 对象属性的取值的集合

## 4. 继承

- 继承: 一个类可以继承另一些类
    - 被继承的类称为超类
    - 继承超类的类称为子类
    - 子类自动拥有超类所拥有的属性与方法, 作为子类的超类属性与超类方法
- 当调用子类自己没有定义的方法时, 将尝试调用它的超类方法
