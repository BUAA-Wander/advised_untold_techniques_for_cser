# 6.5.作用域

- 变量: 指向对象 (值) 的名称
- 命名空间, 作用域 Scope: 用于存储变量的字典, 保存标识符 (名称) 字符串到对应对象 (值) 的映射: `{('identifier': object)*}`
- 全局作用域: 程序的基础作用域, 位于所有其他作用域之外的作用域
    - 全局作用域中定义的变量称为全局变量
    - 最好避免使用全局变量
- 局部作用域:
    - 局部作用域中定义的变量称为局部变量
    - 每次函数调用都将基于当前作用域创建一个新的独立的子作用域, 供函数中的代码块使用
        - 函数的形式参数类似于函数中的局部变量
    - 每次定义类都将基于当前作用域创建一个新的独立的子作用域`Class` (类属作用域), 供类中的代码块使用
    - 每次创建类实例都将基于当前作用域创建一个新的独立的子作用域`self` (类实例作用域), 供类实例中的代码块使用
    - 每个新文件 (模块) 都创建一个模块作用域
        - 当模块作为程序运行时, 本模块作用域成为该次运行的全局作用域
        - 当模块被`from module import *`导入时, 本模块作用域中的公有属性合并入全局作用域
        - 当模块被`import module`导入时, 本模块作用域成为全局作用域的子作用域: `module`
- 全体作用域形成一个以全局作用域为根节点的树形结构
- 对作用域字典的修改将影响作用域中的变量和对象
- 对作用域中的变量和对象的修改将影响作用域字典
- `vars([object]) -> dictionary`
    - 内置函数
    - 当未提供`object`时, 返回当前局部作用域字典
    - 当提供`object`时, 返回`object.__dict__`, 即对象的实例作用域
- `locals() -> dictionary`
    - 内置函数
    - 返回当前局部作用域字典
- 注意: 修改局部作用域字典的结果是不确定的
- `globals() -> dictionary`
    - 内置函数
    - 返回全局作用域字典
- 在局部作用域中声明全局变量: `global name(, name)*`
- 在局部作用域中访问全局作用域中的变量
    - 读取: 仅读取全局变量的值, 而不对它赋值
        - 若无同名局部变量/函数参数覆盖: 直接访问: `name`
            - 局部作用域可以访问全局作用域中的变量
            - 注意: 直接访问全局变量是众多bug的根源, 慎重使用
        - 被声明为全局变量的名称: 直接访问: `name`
        - 屏蔽, 遮盖: 当局部变量或函数参数与全局变量同名, 全局变量将被屏蔽 (遮盖), 无法从局部作用域中直接访问, 但并不会影响或修改全局变量的值
            - 访问局部变量/函数参数: 直接访问: `name`
            - 此时, 可通过全局作用域字典访问全局变量: `global()['name']`
    - 写入: 对全局变量赋值, 即将它重新关联到新对象
        - 局部作用域内的赋值语句默认在局部作用域中执行, 所定义的变量默认为局部变量, 不影响全局作用域
        - 局部作用域内对被声明为全局变量的名称的赋值在全局作用域中执行, 所定义的变量为全局变量
- 访问任意作用域中的变量: `scope['name']`
    - 注意: 避免对该种方法访问的变量赋值, 考虑到`scope`可能是局部作用域, 这种赋值的结果是不确定的
- 闭包: 函数能够存储和访问其**被定义**时的各超作用域
    - 被定义时的各超作用域优先于全局作用域被访问
    - 注意: 闭包函数存储并访问的是定义时的各超**作用域**及其中的**变量**, 而非定义时的各超作用域**状态**及其变量**值 (所关联的对象)**:
    - 注意: 函数能够存储和访问其被定义时的各超作用域, 包括间接超作用域, 不仅仅包括直接超作用域

```python3
def wrapper(content: str) -> None:
    def inner() -> None:
        print(content)
    content = "Reassigned after closure function's definition"
    inner()

wrapper("Assigned before closure fuction's definition")
# 定义时的变量值: "Assigned before closure fuction's definition"
# 定义时的变量在被`print(content)`读取时的值: "Reassigned after closure function's definition"
# 将打印"Reassigned after closure function's definition"
```

- 仅用于辅助当前函数, 不会在其他地方用到的辅助函数可以定义在当前函数内
