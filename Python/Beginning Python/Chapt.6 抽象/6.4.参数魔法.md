# 6.4.参数魔法

## 1. 值从哪里来

- 应确保函数在被提供的参数正确时完成任务, 在被提供的参数错误时以显而易见的方式失败
    - 为此, 通常使用断言和异常
- 形式参数: def语句中位于函数名后面的**标识符**
- 实际参数: 调用函数时提供的**对象** (**值**)

## 2. 修改参数

- 参数是变量
- 参数存储在局部作用域内
- 函数内的局部名称 (包括参数) 会屏蔽函数外的同名名称
- 在函数内给参数赋值, 即将参数名重新绑定到新对象, 对函数外部的变量没有影响
- 不可变对象 Immutable: 状态不可变的对象 (只能将名称重新绑定到新的对象), 如字符串, 数值, 元组
- 可变对象 Mutable: 状态可变的对象, 如列表
- 将同一个可变对象赋给两个变量时, 这两个变量将指向同一个可变对象. 要避免这样的结果, 可以创建可变对象的副本. 这样, 这两个变量指向两个 (暂时) 相等但不相同的可变对象

### 2.1. 为何要修改参数

- 使用函数来修改数据结构可以提高程序的抽象程度: `process(data_structure)`

### 2.2. 如果参数是不可变的

- 如果需要将对不可变参数的值的修改传递到函数外部, 应由函数返回修改后的值, 再在函数外部对原变量赋予新值

```python3
def update(value):
    # ...
    return updated_value

value = update(value)
```

## 3. 关键字参数和默认值

- 调用函数时提供参数的方式分为两种: `fuction(argument_list)`
    - 位置参数 Positional Argument: 直接给出值, 值根据位置从左到右依序与参数名配对: `value`
    - 关键字参数 Keyword Argument: 给出参数名和值, 值根据关键字与指定参数名配对: `name=value`
        - 优点
            - 不必关心参数的排列顺序
            - 表明各个参数的含义
    - 同一个函数调用中可以结合使用位置参数与关键字参数
        - 通常应避免结合使用, 除非非默认值参数很少, 而默认值参数很多
    - 注意: 调用函数时, 位置参数必须在关键字参数之前
        - 避免不能确定关键字参数是否占据位置
- 定义函数时定义参数的方式分为两种: `def fuction(argument_definition):`
    - 非默认值参数 Non-default Argument: 只给出参数名, 不给出默认值的参数: `name`
    - 默认值参数 Default Argument: 给出参数名和默认值的参数: `name=default_value`
        - 调用函数时可以不向默认值参数提供值. 此时, 默认值参数将具有默认值
        - 参数的默认值在函数定义时求值, 而非函数调用时
            - 因此, 多次函数调用中的参数默认值是同一个对象
    - 同一个函数定义中可以结合使用非默认值参数与默认值参数
    - 注意: 定义函数时, 无默认值参数必须在默认值参数之前
        - 避免调用时通过位置参数的形式提供值时不能确定是否省略了某个默认值参数
- 在函数文档中, 使用`[]`标记其中的参数是可选的
- 由于参数默认值在函数定义时求值, 方法不能在参数默认值中访问`self`

在方法参数默认值中 "访问" `self`的方法:

```python3
NOTHING = object()  # Mark; Avoid `None` because it may be a valid value
class Class:
    def method(self, arg=NOTHING):
        if arg is NOTHING:
            arg = self.value
```

## 4. 收集参数

- 在定义函数时, 有以下两种特殊的形式参数: `def fuction(argument_list):`
    - 单星号参数: `*name`
        - 收集多余的位置参数: 单星号参数得到形式参数定义列表中之前各参数分别得到位置参数值后剩余的位置参数值所组成的元组
            - 类似于序列解包中的带星号变量, 但得到元组而非列表
        - 如果没有剩余的位置参数值, 单星号参数得到一个空元组
        - 单星号参数不会收集关键字参数
        - 单星号参数可以位于形式参数定义列表中默认值参数之前的任意位置
        - 单星号参数只能接收多余的位置参数, 不能通过关键字参数直接指定值
        - 形式参数定义列表中位于单星号参数之后的参数只能通过关键字参数指定值, 而不能通过位置参数指定值
            - 因为从该位置开始之后的任何位置参数都会被视为传递给单星号参数的值
        - 此时, 所提供的位置参数的个数可以多于单星号参数之前的形式参数的个数
        - 同一个形式参数定义列表中最多只能有一个单星号参数
        - 单星号参数允许用户提供任意数量的位置参数
        - 单星号参数不能定义默认值
    - 双星号参数: `**name`
        - 收集多余的关键字参数: 双星号参数得到关键字未与其他形式参数名匹配的关键字参数的关键字字符串与关键字参数值键值对组成的字典
        - 如果没有未匹配的关键字参数, 双星号参数得到一个空字典
        - 双星号参数不会收集位置参数
        - 双星号参数必须位于形式参数定义列表的末尾位置
        - 双星号参数只能接收多余的关键字参数, 不能通过关键字参数直接指定值, 也不能通过位置参数指定值
        - 此时, 所提供的关键字参数的个数可以多余除双星号参数之外的形式参数的个数
        - 同一个形式参数定义列表中最多只能有一个双星号参数
        - 双星号参数允许用户提供任意数量的关键字参数
        - 双星号参数不能定义默认值
- 在定义函数时, 有以下两种特殊的指示形式参数
    - `/`: 之前的参数只能通过位置参数指定值 Positional Only, 不能通过关键字参数指定值
        - 名称不重要且总是以固定顺序指定值的参数可限定为仅限位置参数指定值 Positional Only
        - 斜杠指示形式参数与单星号形式参数同时使用时, 斜杠指示形式参数必须放在单星号形式参数之前
    - `*`: 标志可通过位置参数指定值的参数的结束, 之后的参数只能通过关键字参数指定值 Keyword Only, 不能通过位置参数指定值
        - 名称重要且有助于使函数调用更可读的参数可限定为仅限关键字参数指定值 Keyword Only
        - 星号指示形式参数与斜杠指示形式参数同时使用时, 星号指示形式参数必须放在斜杠指示形式参数之后

## 5. 分配参数

- 模块operator提供了高效的操作符函数
- 在函数调用而非定义时使用单星号运算符`*`将可迭代对象的元素值分配为位置参数: `*iterable`
    - 相当于对可迭代对象解包
    - 同一次函数调用中可使用任意次单星号运算符
    - 单星号运算符可出现在函数调用实际参数列表中的任何位置
- 在函数调用而非定义时使用双星号运算符`**`将字典中的值分配给键字符串内容对应的关键字参数: `**dictionary`
    - 相当于对字典解包
    - 同一次函数调用中可使用任意次双星号运算符
    - 双星号运算符可出现在函数调用实际参数列表中的任何位置
- 当在函数定义与调用中均使用`*`或`**`时, 对象 (可迭代对象或字典) 经过解包再收集 (打包), 相当于直接传递对象本身
- 使用收集和分配参数的运算符在函数间传递参数非常有用
    - 无需关心参数个数
    - 在调用超类构造函数时特别有用

```python3
def call_function(*position_arguments, **keyword_arguments):
    function(*position_arguments, **keyword_arguments)
```

## 6. 练习使用参数

- 函数调用
    - 位置参数
    - 关键字参数
    - 序列解包参数
    - 字典解包参数
- 函数定义
    - 非默认值参数
    - 默认值参数
    - 单星号参数
    - 双星号参数
    - 斜杠指示参数
    - 星号指示参数
- 函数文档
    - 可选参数
